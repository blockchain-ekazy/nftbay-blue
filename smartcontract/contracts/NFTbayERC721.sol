// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract NFTbayERC721 is IERC2981, AccessControl, ERC721Enumerable {
    using Counters for Counters.Counter; // counters for marketplace
    using Strings for uint256;

    Counters.Counter private actualTotalSupply; // total NFTs Minted including NFTs burn

    bytes32 private constant MINTER_ROLE =
        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; //keccak256("MINTER_ROLE");
    bytes32 private constant CONTRACT_ROLE =
        0x364d3d7565c7a8300c96fd53e065d19b65848d7b23b3191adcd55621c744223c; //keccak256("CONTRACT_ROLE");
    // one or more smart contracts allowed to call the mint function, eg. the Marketplace contract

    uint24 private constant ARTIST_FEE = 500;
    string private _baseTokenURI; // Base URI
    address payable private _paymentSplitter;
    uint24 private _serviceFeeBPs;

    mapping(uint256 => string) private _tokenURIs; // Optional mapping for token URIs
    mapping(uint256 => bool) private _isSecondarySale; // to check if this token has been sold before
    mapping(uint256 => address) private artists; // token Id to artist mapping, used for sending fees to artist on secondary sales

    /**
     * @dev Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE` role.
     */
    function mint(string memory _tokenURI, address _to)
        external
        onlyRole(MINTER_ROLE)
    {
        uint256 tokenId = actualTotalSupply.current();

        _mint(_to, tokenId); // using total supply as counter, since tokens cannot be burned we don't need a separate counter
        _setTokenURI(tokenId, _tokenURI); // set URI after minting
        artists[tokenId] = _to;
        actualTotalSupply.increment();
    }

    /**
     * @dev update payment splitter contract address
     *
     * Requirements:
     *
     * - the caller must have the `DEFAULT_ADMIN_ROLE` role.
     */
    function updatePaymentSplitter(address payable _addr)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(_addr != address(0), "0x address");
        _paymentSplitter = _addr;
    }

    function setServiceFeeBPs(uint24 serviceFee_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _serviceFeeBPs = serviceFee_;
    }

    /**
     * @notice  only either auction or marketplace contract can call it to set tokenId as secondary sale.
     * @param _tokenId ERC721 NFTs' tokenId
     *
     */
    function setSecondarySale(uint256 _tokenId)
        external
        onlyRole(CONTRACT_ROLE)
    {
        _isSecondarySale[_tokenId] = true;
    }

    /**
     * Optional function to set the base URI
     */
    function setBaseURI(string memory baseURI_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _baseTokenURI = baseURI_;
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI)
        internal
        virtual
    {
        require(_exists(tokenId), "nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }

    /*****************************/
    /****** View Functions *******/
    /*****************************/

    function isSecondarySale(uint256 tokenId) external view returns (bool) {
        require(_exists(tokenId), "nonexistent token");
        return _isSecondarySale[tokenId];
    }

    function paymentSplitter() external view returns (address) {
        return _paymentSplitter;
    }

    function serviceFeeBPs() external view returns (uint24) {
        return _serviceFeeBPs;
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "nonexistent token");

        string memory _tokenURI = _tokenURIs[tokenId];
        string memory base = _baseURI();

        // If there is no base URI, return the token URI.
        if (bytes(base).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(base, _tokenURI));
        }

        return super.tokenURI(tokenId);
    }

    /**
     * @dev overrides the base function which is empty by default
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /// @inheritdoc	IERC2981
    function royaltyInfo(uint256 _tokenId, uint256 value)
        external
        view
        override
        returns (address receiver, uint256 royaltyAmount)
    {
        require(_exists(_tokenId), "nonexistent token");

        receiver = artists[_tokenId];
        royaltyAmount = (value * ARTIST_FEE) / 10000;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IERC165, AccessControl, ERC721Enumerable)
        returns (bool)
    {
        return
            interfaceId == type(IERC2981).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI // e.g. https://ipfs.io/ipfs/
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        _serviceFeeBPs = 100; // 1% service fee paid to  marketplace
    }
}
